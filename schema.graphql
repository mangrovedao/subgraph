type Account @entity(immutable: true) {
  id: Bytes!
  address: Bytes!
}

type Market @entity {
  id: String!
  outbound_tkn: Bytes! # address
  inbound_tkn: Bytes! # address
  active: Boolean!
}

type Offer @entity {
  id: String!
  transactionHash: Bytes!
  offerId: BigInt!
  wants: BigInt!
  initialWants: BigInt!
  gives: BigInt!
  initialGives: BigInt!
  gasprice: BigInt!
  gasreq: BigInt!
  prev: BigInt!
  isOpen: Boolean!
  isFailed: Boolean!
  isFilled: Boolean!
  # Price, do we want to calcuate it in the UI, Query or save it here?
  # deprovision, we need to keep track, if an offer has been deprovisioned or not
  isRetracted: Boolean!
  failedReason: Bytes
  posthookFailReason: Bytes

  market: Market!
  maker: Account!
  kandel: Kandel
  owner: Account
}

type Order @entity {
  id: String!
  transactionHash: Bytes!
  type: String! # MARKET or LIMIT

  taker: Bytes
  takerGot: BigInt
  takerGave: BigInt
  penalty: BigInt
  feePaid: BigInt
  # Missing expiry date
  # How do i know what market it was for?
  # The settings FillWants, FillOrKill, and restingOrder are not saved
  # We e.g. use FillWants in to know if it was a Buy or Sell order.
  # Price, do we want to calcuate it in the UI, Query or save it here?
  # status, do we want to calcuate it in the UI, Query or save it here?
  

  offer: Offer
  realTaker: Bytes # for market order it's equal taker
}

type KandelDepositWithdraw @entity {
  id: String!
  transactionHash: Bytes!
  date: BigInt!
  token: Bytes!
  amount: BigInt!
  isDeposit: Boolean!

  kandel: Kandel!
}

type Kandel @entity {
  id: Bytes!
  transactionHash: Bytes!
  seeder: Bytes!
  address: Bytes!

  base: Bytes!
  depositedBase: BigInt!
  depositedQuote: BigInt!

  totalBase: BigInt!
  totalQuote: BigInt!

  quote: Bytes!

  gasprice: BigInt
  
  owner: Account!

  offers: [Offer!]! @derivedFrom(field: "kandel")
  depositWithdraws: [KandelDepositWithdraw!]! @derivedFrom(field: "kandel")
}

type Contex @entity {
  id: String!
  ids: String!
  last: Order
}
